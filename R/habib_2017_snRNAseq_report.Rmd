---
title: "Habib 2017 snRNAseq Report"
author:
  - name: "Emir Turkes [et2628@cumc.columbia.edu]"
  - name: "Columbia University"
date: '`r strftime(Sys.time(), format = "%B %d, %Y")`'
bibliography: "../habib-2017-snRNAseq.bib"
biblio-style: apalike
link-citations: true
output:
  html_document:
    number_sections: true
    theme: lumen
    highlight: haddock
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
      smooth_scroll: false
knit:
  (function(inputFile, encoding) {
    rmarkdown::render(
      inputFile, encoding = encoding, output_file = "../results/habib-2017-snRNAseq-report.html")})
---

```{r, include = FALSE}
#    This file is part of habib-2017-snRNAseq.
#    Copyright (C) 2019  Emir Turkes
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Emir Turkes can be contacted at emir.turkes@eturkes.com

knitr::opts_chunk$set(fig.width = 8.5, fig.height = 7)
```

<style type="text/css">
body {font-size: 16px;}
h1.title {font-size: 35px;}
h1 {font-size: 24px;}
h2 {font-size: 22px;}
h3 {font-size: 20px;}
.toc-content {padding-left: 0px; padding-right: 0px;}
div.tocify {width: 100%;}
.tocify-subheader .tocify-item {font-size: 0.95em; padding-left: 25px; text-indent: 0;}
div.main-container {max-width: none; width: 100%;}
</style>

*This is a broad initial analysis that prepares and characterizes the data for use in other projects.*

The background for this data is as follows:

- dbGaP Accession: [phs000424](https://www.ncbi.nlm.nih.gov/projects/gap/cgi-bin/study.cgi?study_id=phs000424.v7.p2).
- Part of [GTEx](https://gtexportal.org/home/) and originally published in @habib_massively_2017.
- Archived frozen adult human post-mortem tissue from 5 donors.
- 3 prefrontal cortex samples, 4 hippocampal samples.
- 14,963 nuclei, 31,930 genes.

This analysis was performed in R except where noted.
The source code and instructions for rerunning the analysis can be found at [github.com/eturkes/habib-2017-snRNAseq](https://github.com/eturkes/habib-2017-snRNAseq).

# Final Results

**Read just the following sub-sections (1.1-1.4) for the final results of the analysis and a brief summary of the methods.**

```{r, include = FALSE}
results_dir <- file.path(getwd(), "..", "results")

packages <- c(
  "conflicted", "BiocFileCache", "data.table", "DT", "SingleCellExperiment", "biomaRt", "S4Vectors",
  "dplyr", "SummarizedExperiment", "DropletUtils", "scater", "scran", "ggrepel", "BiocSingular",
  "ggplot2", "rsvd", "Rtsne", "Seurat", "viridis")
invisible(suppressPackageStartupMessages(lapply(packages, library, character.only = TRUE)))

options(stringsAsFactors = FALSE)

# ggplot2 function providing custom aesthetics and automatic placement of categorical labels.
# For continuous data, a colorbar is implemented.
dim_red_plot <- function(data, x, y, col, type) {
  gg <- ggplot(data, aes_string(x = x, y = y, color = col)) +
    geom_point(alpha = 0.35, stroke = 0.05, shape = 21, aes_string(fill = col)) +
    theme_classic() +
    theme(
      legend.position = "right", plot.title = element_text(hjust = 0.5),
      legend.title = element_blank()) +
    guides(color = guide_legend(override.aes = list(alpha = 1)))
    if (type == "cat") {
      gg <- gg + geom_label_repel(data = label_df2, aes(label = label), show.legend = FALSE)
    } else if (type == "cont") {
      gg <- ggplot(data, aes_string(x = x, y = y)) +
        geom_point(alpha = 0.35, stroke = 0.05, aes_string(color = col)) +
        theme_classic() +
        theme(
          legend.position = "right", plot.title = element_text(hjust = 0.5),
          legend.title = element_blank()) +
        scale_colour_viridis()}
  gg}

sce_orig <- readRDS(file.path(results_dir, "data", "sce_orig.rds"))
sce <- readRDS(file.path(results_dir, "data", "sce.rds"))
sce_hvg <- readRDS(file.path(results_dir, "data", "sce_hvg.rds"))
seurat_hvg <- readRDS(file.path(results_dir, "data", "seurat_hvg.rds"))
seurat_hvg_markers <- readRDS(file.path(results_dir, "data", "seurat_hvg_markers.rds"))
```

## SCE and Seurat Objects

The dataset in @habib_massively_2017 includes transcript counts, cluster labels, and tSNE coordinates, which were used to recreate Figure 2a of the paper following protocols described in the methods section where possible.
The processed data is included in this analysis as an SCE (SingleCellExperiment) object alongside an SCE subsetted to the top HVGs (highly variable genes, about 5,000 selected) and an SCE without additional QC.
A Seurat object was also created using the HVGs, along with its marker genes
All objects can be found in the `results/data/` directory.

```{r, message = FALSE}
sce_orig
sce
sce_hvg
seurat_hvg
head(seurat_hvg_markers)
```

## Replication of Figure 2a {.tabset}

The below tabs display reproductions and replications of Figure 2a from @habib_massively_2017.
Note the presence of several "Unlabeled" clusters that are included in the dataset but removed from the final figures in the publication.
Overall, it can be seen that our reproduction and replication of the results in @habib_massively_2017 agree well with the original publication, with some reasonable deviation in the clustering.
These differences suggest both room for improving this analysis and new findings that may complement the original paper.

```{r, include = FALSE}
# Set up data frame for ggplot2.
gg_df <- data.frame(
  colData(sce)[ , c(
    paste0("habib_tsne", 1:2), paste0("hvg_tsne", 1:2),
    "habib_cluster_name", "seurat_hvg_clusters_name")])
rownames(gg_df) <- NULL
gg_df$habib_cluster_name <- factor(gg_df$habib_cluster_name)
gg_df$seurat_hvg_clusters_name <- factor(gg_df$seurat_hvg_clusters_name)
```

### Habib Clusters Habib tSNE

```{r, echo = FALSE, message = FALSE}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  habib_cluster_name = levels(gg_df$habib_cluster_name), label = levels(gg_df$habib_cluster_name))
label_df2 <- gg_df %>%
  group_by(habib_cluster_name) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "habib_tsne1", y = "habib_tsne2",col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("Habib Clusters Habib tSNE")
```

### HVG Seurat Clusters Habib tSNE

```{r, echo = FALSE, message = FALSE}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  seurat_hvg_clusters_name = levels(gg_df$seurat_hvg_clusters_name),
  label = levels(gg_df$seurat_hvg_clusters_name))
label_df2 <- gg_df %>%
  group_by(seurat_hvg_clusters_name) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "habib_tsne1", y = "habib_tsne2",
  col = "seurat_hvg_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("HVG Seurat Clusters Habib tSNE")
```

### HVG Seurat Clusters HVG tSNE

```{r, echo = FALSE, message = FALSE}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  seurat_hvg_clusters_name = levels(gg_df$seurat_hvg_clusters_name),
  label = levels(gg_df$seurat_hvg_clusters_name))
label_df2 <- gg_df %>%
  group_by(seurat_hvg_clusters_name) %>%
  summarize(hvg_tsne1 = median(hvg_tsne1), hvg_tsne2 = median(hvg_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne1", y = "hvg_tsne2", col = "seurat_hvg_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("HVG Seurat Clusters HVG tSNE")
```

### Habib Clusters HVG tSNE

```{r, echo = FALSE, message = FALSE}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  habib_cluster_name = levels(gg_df$habib_cluster_name), label = levels(gg_df$habib_cluster_name))
label_df2 <- gg_df %>%
  group_by(habib_cluster_name) %>%
  summarize(hvg_tsne1 = median(hvg_tsne1), hvg_tsne2 = median(hvg_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne1", y = "hvg_tsne2", col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("Habib Clusters HVG tSNE")
```

### Original

![](../assets/habib-fig2a.png)

## Replication of Figure 2d {.tabset}

The heatmaps show differentially upregulated genes for each cell type (formed by combining subclusters).
Though we cannot easily assess our replication's agreement with Figure 2d, due to that figure lacking detailed labels, we see the enrichment of expected canonical genes for each cell type.

### HVG Seurat Clusters

```{r, echo = FALSE, message = FALSE}
top <- seurat_hvg_markers %>% group_by(cluster) %>% top_n(n = 5, wt = avg_logFC)
DoHeatmap(seurat_hvg, features = top$gene, size = 1.5) +
  NoLegend() + scale_fill_gradientn(colors = c("blue", "white", "red"))
```

### Original

![](../assets/habib-fig2d.png)

## Replication of Figure 2b {.tabset}

We successfully replicate the overlay of 6 select marker genes over tSNEs from @habib_massively_2017 and from this analysis.

```{r, echo = FALSE, message = FALSE}
seurat <- as.Seurat(sce, counts = "counts", data = NULL) # Missing genes when using sce_hvg.
habib_tsne <- as.matrix(data.frame(sce$habib_tsne1, sce$habib_tsne2))
colnames(habib_tsne) <- paste0("HabibTSNE_", 1:2)
rownames(habib_tsne) <- colnames(sce)
seurat[["habib_tsne"]] <- CreateDimReducObject(
  embeddings = habib_tsne, key = "HabibTSNE_", assay = DefaultAssay(seurat))
genes <- c("SLC17A7", "SLC1A2", "GAD1", "MBP", "PPFIA2", "PDGFRA")
```

### Habib tSNE

```{r, echo = FALSE, message = FALSE}
FeaturePlot(
  seurat, reduction = "habib_tsne", features = genes, order = TRUE,
  cols = c("lightgrey", "red"), max.cutoff = 20, ncol = 2)
```

### All Genes tSNE

```{r, echo = FALSE, message = FALSE}
FeaturePlot(
  seurat, reduction = "TSNE", features = genes, order = TRUE,
  cols = c("lightgrey", "red"), max.cutoff = 20, ncol = 2)
```

### Original

![](../assets/habib-fig2b.png)

# ~~~ Breakdown of Methods ~~~ {-}

**Sections from here to the end break down the methods used and are optional to read.**

We start by setting some global variables and loading in any required packages.

```{r}
data_str <- "GTEx_droncseq_hip_pcf"
data_dir <- file.path(getwd(), "..", "data")
assets_dir <- file.path(getwd(), "..", "assets")
results_dir <- file.path(getwd(), "..", "results")

packages <- c(
  "conflicted", "BiocFileCache", "data.table", "DT", "SingleCellExperiment", "biomaRt", "S4Vectors",
  "dplyr", "SummarizedExperiment", "DropletUtils", "scater", "scran", "ggrepel", "BiocSingular",
  "ggplot2", "rsvd", "Rtsne", "Seurat", "viridis")
invisible(suppressPackageStartupMessages(lapply(packages, library, character.only = TRUE)))

options(stringsAsFactors = FALSE)

# Create a cache for storing the objects of long-running computations.
if (!dir.exists(file.path(assets_dir, "cache"))) {
  dir.create(file.path(assets_dir, "cache"))}

# ggplot2 function providing custom aesthetics and automatic placement of categorical labels.
# For continuous data, a colorbar is implemented.
dim_red_plot <- function(data, x, y, col, type) {
  gg <- ggplot(data, aes_string(x = x, y = y, color = col)) +
    geom_point(alpha = 0.35, stroke = 0.05, shape = 21, aes_string(fill = col)) +
    theme_classic() +
    theme(
      legend.position = "right", plot.title = element_text(hjust = 0.5),
      legend.title = element_blank()) +
    guides(color = guide_legend(override.aes = list(alpha = 1)))
    if (type == "cat") {
      gg <- gg + geom_label_repel(data = label_df2, aes(label = label), show.legend = FALSE)
    } else if (type == "cont") {
      gg <- ggplot(data, aes_string(x = x, y = y)) +
        geom_point(alpha = 0.35, stroke = 0.05, aes_string(color = col)) +
        theme_classic() +
        theme(
          legend.position = "right", plot.title = element_text(hjust = 0.5),
          legend.title = element_blank()) +
        scale_colour_viridis()}
  gg}
```

# Original Data {.tabset}

This section provides a brief look at the raw data before manipulation.

```{r}
bfc <- BiocFileCache(data_dir, ask = FALSE)
data <- bfcrpath(bfc, file.path(
  "https://storage.googleapis.com/gtex_additional_datasets/single_cell_data",
  paste0(data_str, ".tar")))
untar(data, exdir = tempdir())
rm(bfc)
```

## Counts

```{r}
counts <- fread(
  file.path(tempdir(), data_str, paste0(data_str, ".umi_counts.txt.gz")), data.table = FALSE)
datatable(counts[1:5, 1:3])
```

## Clusters

```{r}
# The original clusters file, GTEx_droncseq_hip_pcf.clusters.txt, has several inconsistencies.
# Specifically in clusters 15-18, which do not match those in the original publication.
# Therefore we use Supplementary Table 7 (nmeth.4407-S10.xlsx), which does not have those issues.
# However, because cluster 11 is incorrectly named in this table, we must correct that.
# Also, as this file contained non-standard formatting, minimal manual editing was done for use in R.
clust <- fread(file.path(assets_dir, "nmeth.4407-S10-edited.txt"), data.table = FALSE)
datatable(clust[1:5, ])
```

## tSNE

```{r}
tsne <- fread(file.path(tempdir(), data_str, paste0(data_str, ".tsne.txt.gz")), data.table = FALSE)
datatable(tsne[1:5, ])
```

# Preliminary Cleaning

Here we do any data wrangling neccessary to transform the data into more convenient formats for downstream analysis.

## Counts

```{r}
rownames(counts) <- counts[ , 1]
counts <- as.matrix(counts[ , -1])
cell_id_stem <- sapply(colnames(counts), function(xx) strsplit(xx, "_")[[1]][1], USE.NAMES = FALSE)
col_dat <- data.frame(sample = colnames(counts), cell_id_stem = cell_id_stem, check.names = FALSE)
datatable(counts[1:5, 1:3])

# Convert to dgCMatrix after datatable, as they are incompatible.
counts <- Matrix::Matrix(counts, sparse = TRUE)
```

## Clusters

```{r}
# Fix mislabeled cluster name and give unique names for unclassified clusters.
for (i in seq_len(nrow(clust))) {
  if (clust[i, 4] == 11) {
    clust[i, 5] <- "ODC2"
  } else if (clust[i, 4] == 16) {
    clust[i, 5] <- "Unlabeled1"
  } else if (clust[i, 4] == 17) {
    clust[i, 5] <- "Unlabeled2"
  } else if (clust[i, 4] == 18) {
    clust[i, 5] <- "Unlabeled3"}}

clust <- clust[ , -c(2:3)]
names(clust) <- c("sample", "habib_cluster", "habib_cluster_name")
clust$habib_cluster <- factor(clust$habib_cluster)
clust <- clust[match(col_dat$sample, clust$sample), ]
rownames(clust) <- NULL
datatable(clust[1:5, ])
```

## tSNE

```{r}
names(tsne) = c("sample", paste0("habib_tsne", 1:2))
datatable(tsne[1:5, ])
```

## SingleCellExperiment

The data is now sufficiently prepared to form an SCE object.

```{r}
col_dat <- cbind(col_dat, clust[ , names(clust) != "sample"], tsne[ , names(tsne) != "sample"])
sce <- SingleCellExperiment(assays = list(counts = counts), colData = col_dat)
rm(counts, clust, tsne, col_dat)
sce
```

## Gene Annotations

In order to use standard gene symbols, which are often useful for downstream analysis, we add annotations based on the hg19 reference gnome, the same used in @habib_massively_2017.

```{r}
attributes <- c(
  "hgnc_symbol", "ensembl_gene_id", "external_gene_name", "chromosome_name", "start_position",
  "end_position", "strand", "description", "percentage_gene_gc_content", "gene_biotype")
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "gene_anno.rds")
if (file.exists(rds)) {
  gene_anno <- readRDS(rds)
} else {
  mart <- useEnsembl(biomart = "ensembl", GRCh = 37, dataset = "hsapiens_gene_ensembl")
  gene_anno <- getBM(
    attributes = attributes, filters = "external_gene_name", values = rownames(sce), mart = mart)
  saveRDS(gene_anno, rds)
  rm(mart)}
```

Before merging them into the SCE object, the annotation must be cleaned by removing genes not in the RNAseq dataset, irrelevant annotations, duplicate genes, and genes that are not annotated.

```{r}
# Remove genes not in the RNAseq dataset.
remove_genes <- which(!gene_anno$external_gene_name %in% rownames(sce))
gene_anno <- gene_anno[-remove_genes, ]

# Remove annotations to scaffolds, assembly patches, and alternative loci.
chromosomes <- c(1:22, "X", "Y", "MT")
gene_anno <- gene_anno[which(gene_anno$chromosome_name %in% chromosomes), ]

# Remove duplicates.
dup <- table(gene_anno$external_gene_name)
dup <- sort(dup[dup > 1], decreasing = TRUE)
dup <- which(gene_anno$external_gene_name %in% names(dup))
gene_anno2 <- gene_anno[dup, ]
gene_anno2 <- gene_anno2[which(gene_anno2$hgnc_symbol == gene_anno2$external_gene_name), ]
gene_anno2 <- distinct(gene_anno2, external_gene_name, .keep_all = TRUE)
gene_anno <- rbind(gene_anno[-dup, ], gene_anno2)

# Remove missing.
keep_genes <- match(gene_anno$external_gene_name, rownames(sce))
sce <- sce[keep_genes, ]

rowData(sce) <- gene_anno
names(rowData(sce))[names(rowData(sce)) == "strand"] <- "strand_n" # Conflicts with other packages.
rm(gene_anno, gene_anno2)
names(rowData(sce))
```

# QC

A number of QC steps that would normally be performed here were already carried out in @habib_massively_2017.
In those cases we double-check that they were done and carry them out if not.
We opt not to perform additional QC beyond that described in the paper.

## Empty Droplets

Empty droplets are typically identified as those that have no gene counts or only a small number of them (typically less than 100 to 200, resulting from the capture of ambient RNA).
@habib_massively_2017 describes this filtering as having taken place by the following:

> Nuclei with less than 200 detected genes and less than 10,000 usable reads were filtered out.

Furthermore, the paper states that 19,550 nuclei were extracted, but a subset of 14,963 of them were used for analysis, which is identical to the nuclei counts in the imported dataset.

```{r}
dim(sce)[2]
```

We cannot check for the removal of reads at this point but we can verify that all nuclei have at least 200 detected genes.
A straightforward way to do so is by using the `barcodeRanks` function of `DropletUtils`.
We see from the lower limit of the plot that there is was indeed a cutoff applied at 200 genes.

```{r}
bc_rank <- barcodeRanks(counts(sce))
uniq <- !duplicated(bc_rank$rank)
par(mar = c(5, 4, 2, 1), bty = "n")
plot(
  bc_rank$rank[uniq], bc_rank$total[uniq], log = "xy", xlab = "Rank",
  ylab = "Total Gene Count", cex = 0.5, cex.lab = 1.2)
```

## Low Quality Nuclei

As we already have the number of nuclei used in @habib_massively_2017, we remove no further and only generate metrics to assess the effects of additional QC.
We start by investigating low library and feature sizes, as it is unclear whether the data was filtered on that basis.
Furthermore, we assess the proportion of ribosomal/mitochrondrial gene expression in nuclei, which has little to no mention in the publication.
While mitochrondrial genes are straightforward to extract from their HGNC gene symbol, an annotation set for ribosomal genes had to first be downloaded from HGNC, where they are then loaded from the `assets` directory.

```{r}
ribo_genes <- read.table(file.path(assets_dir, "ribo-genes.txt"), sep = "\t", header = TRUE)
is_mito <- which(rowData(sce)$chromosome_name == "MT")
is_ribo <- which(rowData(sce)$external_gene_name %in% ribo_genes$Approved.Symbol)
sce <- calculateQCMetrics(sce, feature_controls = list(mito = is_mito, ribo = is_ribo))
rm(ribo_genes, bc_rank)

par(mfrow = c(2, 2), mar = c(5, 4, 1, 1), bty = "n")
hist(
  sce$total_counts, xlab = "log10(Library Sizes)", main = "",
  breaks = 20, col = "grey80", ylab = "Number of Nuclei")
hist(
  log10(sce$total_features_by_counts), xlab = "log10(Number of Expressed Genes)", main = "",
  breaks = 20, col = "grey80", ylab = "Number of Nuclei")
hist(
  sce$pct_counts_ribo, xlab = "Ribosomal Proportion Percentage", ylab = "Number of Nuclei",
  breaks = 40, main = "", col = "grey80")
hist(
  sce$pct_counts_mito, xlab = "Mitochondrial Proportion Percentage", ylab = "Number of Nuclei",
  breaks = 80, main = "", col = "grey80")
par(mfrow = c(2, 2), mar = c(5, 4, 1, 1), bty = "n")
smoothScatter(
  log10(sce$total_counts), log10(sce$total_features_by_counts),
  xlab = "log10(Library Sizes)", ylab = "log10(Num. Expressed Genes)")
smoothScatter(
  log10(sce$total_counts), sce$pct_counts_ribo,
  xlab = "log10(Library Sizes)", ylab = "Ribosomal Proportion %")
smoothScatter(
  log10(sce$total_counts), sce$pct_counts_mito,
  xlab = "log10(Library Sizes)", ylab = "Mitochondrial Proportion %")
smoothScatter(
  sce$pct_counts_ribo,sce$pct_counts_mito, xlab = "Ribosomal Proportion %",
  ylab = "Mitochondrial Proportion %")
```

We look at the results if we were to remove outliers on the basis of these metrics.

```{r}
libsize_drop <- isOutlier(sce$total_counts, nmads = 3, type = "lower", log = TRUE)
feature_drop <- isOutlier(sce$total_features_by_counts, nmads = 3, type = "lower", log = TRUE)
mito_drop <- isOutlier(sce$pct_counts_mito, nmads = 3, type = "higher")
ribo_drop <- isOutlier(sce$pct_counts_ribo, nmads = 3, type = "higher")
keep <- !(libsize_drop | feature_drop | mito_drop | ribo_drop)
datatable(data.table(
  "By Library Size" = sum(libsize_drop), "By Feature" = sum(feature_drop),
  "By Mitochondrial" = sum(mito_drop), "By Ribosomal" = sum(ribo_drop),
  Remaining = sum(keep)))
```

It appears that filters for library and feature size had already been applied, but not for ribosomal/mitochrondrial gene expression, important considerations for downstream analysis.

## Lowly Expressed Genes

The methods section of @habib_massively_2017 suggests that filtering of genes had been performed by the following:

> A gene is considered detected in a cell if it has at least two unique UMIs (transcripts) associated with it.
For each analysis, genes were removed that were detected in less than 10 nuclei.

However, we see that this is not the case our current dataset, either because it had not yet been applied or was applied before nuclei removal and not again after.

```{r}
head(rowData(sce)$n_cells_by_counts[order(rowData(sce)$n_cells_by_counts)])
```

It can be seen that the presence of these genes creates a distinctly negative skew, which may have unwanted effects on downstream analysis.

```{r, fig.height = 5}
par(mfrow = c(1, 3), mar = c(5, 4, 1, 1))
hist(
  log10(rowData(sce)$mean_counts + 1e-6), col = "grey80",  main = "",
  breaks = 40, xlab = "log10(Average Number of UMI + 1e-6)")
hist(
  log10(rowData(sce)$n_cells_by_counts + 1), col = "grey80", main = "",
  breaks = 40, xlab = "log10(Number of Expressed Nuclei + 1)")
plot(
  log10(rowData(sce)$mean_counts + 1e-6), pch = 16,
  col = rgb(0, 0, 0, 0.4), log10(rowData(sce)$n_cells_by_counts + 1),
  xlab = "log10(Average Number of UMI + 1e-6)", ylab = "log10(Number of Expressed Nuclei + 1)")
```

Therefore, we remove genes in the manner specified in @habib_massively_2017.
As this step is destructive, we first set aside a copy of our SCE object thus far to be saved later.

```{r}
sce_orig <- sce
detected_genes <- rowSums(counts(sce) >= 2)
sce <- sce[which(detected_genes >= 10), ]
head(rowData(sce)$n_cells_by_counts[order(rowData(sce)$n_cells_by_counts)])
dim(sce)[1]
```

We see a robust improvement in normality.

```{r, fig.height = 5}
sce <- calculateQCMetrics(sce)
par(mfrow = c(1, 3), mar = c(5, 4, 1, 1))
hist(
  log10(rowData(sce)$mean_counts + 1e-6), col = "grey80",  main = "",
  breaks = 40, xlab = "log10(Average Number of UMI + 1e-6)")
hist(
  log10(rowData(sce)$n_cells_by_counts + 1), col = "grey80", main = "",
  breaks = 40, xlab = "log10(Number of Expressed Nuclei + 1)")
plot(
  log10(rowData(sce)$mean_counts + 1e-6), pch = 16,
  col = rgb(0, 0, 0, 0.4), log10(rowData(sce)$n_cells_by_counts + 1),
  xlab = "log10(Average Number of UMI + 1e-6)", ylab = "log10(Number of Expressed Nuclei + 1)")
```

We then display some additional summary statistics.
Apparent is the disproportionately high expression of encoding lncRNAs MALAT1 and MEG3, both of which are known to have higher expression in nuclei, as noted in @habib_massively_2017.

```{r}
plotHighestExprs(sce, exprs_values = "counts")
plotExprsFreqVsMean(sce)
```

## Normalization

We use `computeSumFactors` from the `scran` package to perform normalization.
This function uses a linear deconvolution system to account for expected variation across different cell types/sizes, producing "size factor" values that indicate the extent to which nuclei should be scaled.
We also perform a rough clustering of our nuclei, which improves accuracy on highly heterogenous data such as that from the brain.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "quickCluster.rds")
if (file.exists(rds)) {
  quickCluster <- readRDS(rds)
} else {
  set.seed(1)
  quickCluster <- quickCluster(sce, use.ranks = FALSE, BSPARAM = IrlbaParam())
  saveRDS(quickCluster, rds)}
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "size_factors.rds")
if (file.exists(rds)) {
  size_factors <- readRDS(rds)
} else {
  size_factors <- computeSumFactors(sce, cluster = quickCluster, min.mean = 0.1)
  saveRDS(size_factors, rds)}
```

In an experiment where most systematic differences between nuclei are driven by capture efficiency and sequencing depth, we should see a correlation between size factors and library size.

```{r, fig.height = 6}
sce <- size_factors
par(mfrow = c(1, 2), mar = c(5, 4, 2, 1), bty = "n")
smoothScatter(
  sce$total_counts, sizeFactors(sce), log = "xy", xlab = "Total Counts", ylab = "Size Factors")
plot(
  sce$total_counts, sizeFactors(sce), log = "xy", xlab = "Total Counts",
  ylab = "Size Factors", cex = 0.3, pch = 20, col = rgb(0.1, 0.2, 0.7, 0.3))
abline(h = 0.05)
```

The plots are well correlated, confirming the source of bias.
We therefore add normalized expression data to our SCE object using the calculated size factors.

```{r}
sce <- normalize(sce)
sce
```

# Dimensionality Reduction

Before creating our own clusters, we explore the data using various dimensionality reduction techniques.
We start by plotting the coordinates provided in @habib_massively_2017, which were generated off of select PCs after subsetting to the most highly variable genes.
The cluster labeled plot is identical to Figure 2a from the paper, aside from the additional "Unlabeled" cells.

```{r}
# Set up data frame for ggplot2.
gg_df <- data.frame(
  colData(sce)[ , c(
    "cell_id_stem", paste0("habib_tsne", 1:2),
    "log10_total_features_by_counts", "habib_cluster_name")])
rownames(gg_df) <- NULL
gg_df$habib_cluster_name <- factor(gg_df$habib_cluster_name)

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  habib_cluster_name = levels(gg_df$habib_cluster_name),
  label = levels(gg_df$habib_cluster_name))
label_df2 <- gg_df %>%
  group_by(habib_cluster_name) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "habib_tsne1", y = "habib_tsne2",
  col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("Habib Clusters Habib tSNE")
dim_red_plot(
  data = gg_df, x = "habib_tsne1", y = "habib_tsne2", col = "cell_id_stem", type = "other") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("Sample Distribution Habib tSNE")
dim_red_plot(
  data = gg_df, x = "habib_tsne1", y = "habib_tsne2",
  col = "log10_total_features_by_counts", type = "cont") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("log10(Total Features) Habib tSNE")
```

## PCA

Our attempt at replication begins with the PCA function described in @habib_massively_2017:

> We used the fast ‘rpca’ function in R (package ‘rsvd’)...

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "rpca.rds")
if (file.exists(rds)) {
  pca <- readRDS(rds)
} else {
  set.seed(1)
  pca <- rpca(scale(t(as.matrix(logcounts(sce)))), k = 50)
  saveRDS(pca, rds)}
```

```{r}
reducedDims(sce) <- SimpleList(PCA = pca$x)
plotPCA(sce, ncomponents = 4, colour_by = "habib_cluster_name") +
  ggtitle("Habib Clusters PCA") + theme(legend.title = element_blank())
```

@habib_massively_2017 describes the way PC selection was performed, but we do not know the exact number retained:

> [We] chose the most significant principal components (or PCs) based on the largest eigen value gap...

Using a scree plot, we identify a reasonable eiganvalue gap and include all PCs just before the gap for downstream analysis.

```{r}
retain_pcs <- 21
retain_pcs
par(mfrow = c(1, 1))
plot(
  log10(pca$sdev), xlab = "PC", ylab = "log10(Proportion of Variance Explained)",
  pch = 20, cex = 0.6, col = rgb(0.8, 0.2, 0.2, 0.5))
abline(v = retain_pcs, lty = 2, col = "red")
```

## tSNE

@habib_massively_2017 states having used:

> the ‘Rtsne’ package, with a maximum of 2,000 iterations, disabling the initial PCA step and setting the perplexity parameter to 100 for detection of the major clusters...

We use the same method, except setting the perplexity to 50, as 100 is unconventionally high and furthermore did not agree as well with the paper figure.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "Rtsne.rds")
if (file.exists(rds)) {
  tsne <- readRDS(rds)
} else {
  set.seed(1)
  tsne <- Rtsne(pca$x[ , 1:retain_pcs], pca = FALSE, perplexity = 50, max_iter = 2000)
  saveRDS(tsne, rds)}
```

```{r}
reducedDims(sce) <- SimpleList(PCA = pca$x, TSNE = tsne$Y)
add_df <- data.frame(reducedDim(sce, "TSNE"))
names(add_df) <- paste0("allgenes_tsne", seq(ncol(add_df)))
colData(sce) <- cbind(
  colData(sce), allgenes_tsne1 = add_df$allgenes_tsne1, allgenes_tsne2 = add_df$allgenes_tsne2)
gg_df <- data.frame(gg_df, add_df)

# Setup for automatic placement of cluster labels.
label_df2 <- gg_df %>%
  group_by(habib_cluster_name) %>%
  summarize(allgenes_tsne1 = median(allgenes_tsne1), allgenes_tsne2 = median(allgenes_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "allgenes_tsne1", y = "allgenes_tsne2",
  col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("Habib Clusters All Genes tSNE")
dim_red_plot(
  data = gg_df, x = "allgenes_tsne1", y = "allgenes_tsne2", col = "cell_id_stem", type = "other") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("Sample Distribution All Genes tSNE")
dim_red_plot(
  data = gg_df, x = "allgenes_tsne1", y = "allgenes_tsne2",
  col = "log10_total_features_by_counts", type = "cont") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("log10(Total Features) All Genes tSNE")
```

We see that our tSNE is able to resolve the clusters in @habib_massively_2017, though some resolution is lost in the relationship between clusters and within subclusters.
All genes were used for the sake of exploration, but now we reduce our dataset to the top HVGs, as was done in the paper.

## HVG

Describing the selection of HVGs, @habib_massively_2017 states:

> we fit a relationship between mean counts and coefficient of variation using a gamma distribution on the data from all of the genes and ranked genes by the extent of excess variation as a function of their mean expression...

We carry out a similar procedure using the workflow suggested by the `scran` package and then perform dimensionality reduction as described earlier.
As there are no spike-in transcripts, we first model technical noise as Poisson and create a fitted trend on that basis.

```{r}
new_trend <- makeTechTrend(x = sce)
fit <- trendVar(sce, use.spikes = FALSE, loess.args = list(span = 0.05))
par(mfrow = c(1, 1), mar = c(5, 4, 2, 1), bty = "n")
plot(
  fit$mean, fit$var, pch = 20,
  col = rgb(0.1, 0.2, 0.7, 0.6), xlab = "Mean Log-expression", ylab = "Variance")
curve(fit$trend(x), col = "orange", lwd = 2, add = TRUE)
curve(new_trend(x), col = "red", lwd = 2, add = TRUE)
legend(
  "top", legend = c("Poisson Noise", "Observed Trend"), lty = 1,
  lwd = 2, col = c("red", "orange"), bty = "n")
```

The plot shows a large discrepancy between the two trends, which we assume is contributed by each gene's biological component.
We extract the genes with the largest biological components and plot them here.

```{r}
fit$trend <- new_trend
dec <- decomposeVar(fit = fit)
top_dec <- rownames(dec[order(dec$bio, decreasing = TRUE), ])[1:10]
rm(fit)
plotExpression(sce, features = top_dec) +
  stat_summary(
    fun.y = median, fun.ymin = median, fun.ymax = median, geom = "crossbar", width = 0.3, alpha = 0.8)
```

HVG selection is typically in the range of 1,000 to 5,000 [@luecken_current_2019], but @habib_massively_2017 does not state the number of HVGs selected.
We inspect the distribution of our FDR and biological component values to see how see should proceed.

```{r, fig.height = 6}
fdr_median <- median(dec$FDR, na.rm = TRUE)
fdr_median
bio_median <- median(dec$bio, na.rm = TRUE)
bio_median

par(mfrow = c(1, 2))
hist(log10(dec$FDR), breaks = 100, main = "")
abline(v = c(log10(fdr_median), log10(min(dec$FDR[dec$FDR > 0]))), lty = 2, col = "red")
hist(log10(dec$bio), breaks = 100, main = "")
abline(v = c(log10(bio_median), log10(max(dec$bio))), lty = 2, col = "red")
```

We see that thresholding at the median is able to capture most of the desired distribution of both values.
Let's see what number of genes we would subset to with these thresholds.

```{r}
keep <- which(dec$FDR < fdr_median & dec$bio >= bio_median)
sce_hvg <- sce[keep, ]
rm(dec)
dim(sce_hvg)[1]
```

The thresholds capture about 5,000 HVGs, a suitable value for our analysis.
Due to the change in dimensions, we renormalize and calculate new QC metrics.

```{r}
sce_hvg <- calculateQCMetrics(sce_hvg)
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "hvg_quickCluster.rds")
if (file.exists(rds)) {
  quickCluster <- readRDS(rds)
} else {
  set.seed(1)
  quickCluster <- quickCluster(sce_hvg, use.ranks = FALSE, BSPARAM = IrlbaParam())
  saveRDS(quickCluster, rds)}
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "hvg_size_factors.rds")
if (file.exists(rds)) {
  size_factors <- readRDS(rds)
} else {
  size_factors <- computeSumFactors(sce_hvg, cluster = quickCluster, min.mean = 0.1)
  saveRDS(size_factors, rds)}
```

```{r}
sce_hvg <- size_factors
sce_hvg <- normalize(sce_hvg)
rm(size_factors)
sce_hvg
```

The remaining dimensionality reduction sections will use this newly obtained SCE object.

### PCA

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "hvg_rpca.rds")
if (file.exists(rds)) {
  pca <- readRDS(rds)
} else {
  set.seed(1)
  pca <- rpca(scale(t(as.matrix(logcounts(sce_hvg)))), k = 50)
  saveRDS(pca, rds)}
```

```{r}
reducedDims(sce_hvg) <- SimpleList(PCA = pca$x)
plotPCA(sce_hvg, ncomponents = 4, colour_by = "habib_cluster_name") +
  ggtitle("Habib Clusters HVG PCA") + theme(legend.title = element_blank())
```

```{r}
retain_pcs <- 22
retain_pcs
par(mfrow = c(1, 1))
plot(
  log10(pca$sdev), xlab = "PC", ylab = "log10(Proportion of Variance Explained)",
  pch = 20, cex = 0.6, col = rgb(0.8, 0.2, 0.2, 0.5))
abline(v = retain_pcs, lty = 2, col = "red")
```

### tSNE

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "hvg_Rtsne.rds")
if (file.exists(rds)) {
  tsne <- readRDS(rds)
} else {
  set.seed(1)
  tsne <- Rtsne(pca$x[ , 1:retain_pcs], pca = FALSE, perplexity = 50, max_iter = 2000)
  saveRDS(tsne, rds)}
```

```{r}
# Set up data frame for ggplot2.
gg_df <- data.frame(
  colData(sce)[ , c(
    "cell_id_stem", paste0("habib_tsne", 1:2),
    "log10_total_features_by_counts", "habib_cluster_name")])
rownames(gg_df) <- NULL
gg_df$habib_cluster_name <- factor(gg_df$habib_cluster_name)

reducedDims(sce_hvg) <- SimpleList(PCA = pca$x, TSNE = tsne$Y)
add_df <- data.frame(reducedDim(sce_hvg, "TSNE"))
names(add_df) <- paste0("hvg_tsne", seq(ncol(add_df)))
colData(sce_hvg) <- cbind(
  colData(sce_hvg), hvg_tsne1 = add_df$hvg_tsne1, hvg_tsne2 = add_df$hvg_tsne2)
colData(sce) <- cbind(
  colData(sce), hvg_tsne1 = add_df$hvg_tsne1, hvg_tsne2 = add_df$hvg_tsne2)
gg_df <- data.frame(gg_df, add_df)
rm(pca, tsne)

# Setup for automatic placement of cluster labels.
label_df2 <- gg_df %>%
  group_by(habib_cluster_name) %>%
  summarize(hvg_tsne1 = median(hvg_tsne1), hvg_tsne2 = median(hvg_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne1", y = "hvg_tsne2", col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("Habib Clusters HVG tSNE")
dim_red_plot(
  data = gg_df, x = "hvg_tsne1", y = "hvg_tsne2", col = "cell_id_stem", type = "other") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("Sample Distribution HVG tSNE")
dim_red_plot(
  data = gg_df, x = "hvg_tsne1", y = "hvg_tsne2",
  col = "log10_total_features_by_counts", type = "cont") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("log10(Total Features) HVG tSNE")
```

Interestingly, the resulting tSNE is less tightly clustered and appears to capture heterogeneous populations more similarily to @habib_massively_2017 than the tSNE from earlier.
As the authors suggest that they used HVG tSNEs for all downstream visualizations, we do as well.

# Clustering

The previous sections utilized cluster labels provided in @habib_massively_2017, so now we will see if we can generate clusters that replicate them.
The authors describe using the following approach:

> we computed a k-nearest neighbor (k-NN) graph and connected each nucleus to its k-nearest neighbors (based on Euclidean distance, using the ‘nng’ function of the ‘igraph’ package in R).
We next used the k-NN graph as an input to the Infomap algorithm, which decomposes an input graph into modules using the ‘cluster_infomap’ function in R).

## Seurat

We decide to use `Seurat` as it provides a streamlined and optimized nearest neighbor graph clustering method similar (though not identical) to the one described.
As input, we use features and selected PCs from the HVG section and the `resolution` parameter of `FindClusters()` is tweaked to generate the desired 18 clusters.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "seurat_hvg.rds")
if (file.exists(rds)) {
  seurat_hvg <- readRDS(rds)
} else {
  seurat_hvg <- as.Seurat(sce_hvg, counts = "counts", data = NULL)
  seurat_hvg <- NormalizeData(seurat_hvg)
  seurat_hvg <- FindVariableFeatures(seurat_hvg, nfeatures = dim(sce_hvg)[1])
  seurat_hvg <- ScaleData(seurat_hvg, features = rownames(seurat_hvg))
  seurat_hvg <- FindNeighbors(seurat_hvg, reduction = "PCA", dims = 1:retain_pcs)
  seurat_hvg <- FindClusters(seurat_hvg, resolution = 1.05)
  saveRDS(seurat_hvg, rds)}
```

```{r}
gg_df$seurat_hvg_clusters <- seurat_hvg$seurat_clusters
seurat_hvg

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  seurat_hvg_clusters = levels(gg_df$seurat_hvg_clusters), label = levels(gg_df$seurat_hvg_clusters))
label_df2 <- gg_df %>%
  group_by(seurat_hvg_clusters) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "habib_tsne1", y = "habib_tsne2", col = "seurat_hvg_clusters", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("HVG Seurat Clusters Habib tSNE")
```

We compare the result to the clusters from the paper.

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  habib_cluster_name = levels(gg_df$habib_cluster_name),
  label = levels(gg_df$habib_cluster_name))
label_df2 <- gg_df %>%
  group_by(habib_cluster_name) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "habib_tsne1", y = "habib_tsne2",
  col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("Habib Clusters Habib tSNE")
```

Our result shows interesting similarities and differences with that from @habib_massively_2017.
One interpretation is that our approach and chosen parameters have greater power in identifying potentially rare cell types over clustering common cell types (specifically ODC, ASC, and exCA) into evenly distributed subpopulations.
While this finding is not fully represented by the tSNE coordinates from @habib_massively_2017, we see that it is actually well supported by our tSNE generated from the same inputs as Seurat.

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  seurat_hvg_clusters = levels(gg_df$seurat_hvg_clusters), label = levels(gg_df$seurat_hvg_clusters))
label_df2 <- gg_df %>%
  group_by(seurat_hvg_clusters) %>%
  summarize(hvg_tsne1 = median(hvg_tsne1), hvg_tsne2 = median(hvg_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne1", y = "hvg_tsne2", col = "seurat_hvg_clusters", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("HVG Seurat Clusters HVG tSNE")
```

We conclude that our clustering replication was generally successful but with the potential for improvement, and may suggest findings complementary to @habib_massively_2017.

## Labeling {.tabset}

Finally, we assign labels for the new clusters based on their proximity to clusters in the original paper, as well as positions in the new tSNE, and visualize them.

```{r}
gg_df$seurat_hvg_clusters_name <- NA
seurat_hvg_clusters <- as.integer(gg_df$seurat_hvg_clusters)
for (i in 1:length(seurat_hvg_clusters)) {
  if (seurat_hvg_clusters[i] == 1) {
    gg_df[i, ncol(gg_df)] <- "ODC"
  } else if (seurat_hvg_clusters[i] == 2) {
    gg_df[i, ncol(gg_df)] <- "exPFC1.1"
  } else if (seurat_hvg_clusters[i] == 3) {
    gg_df[i, ncol(gg_df)] <- "ASC1"
  } else if (seurat_hvg_clusters[i] == 4) {
    gg_df[i, ncol(gg_df)] <- "exDG"
  } else if (seurat_hvg_clusters[i] == 5) {
    gg_df[i, ncol(gg_df)] <- "exPFC1.2"
  } else if (seurat_hvg_clusters[i] == 6) {
    gg_df[i, ncol(gg_df)] <- "exCA3"
  } else if (seurat_hvg_clusters[i] == 7) {
    gg_df[i, ncol(gg_df)] <- "GABA1"
  } else if (seurat_hvg_clusters[i] == 8) {
    gg_df[i, ncol(gg_df)] <- "GABA2"
  } else if (seurat_hvg_clusters[i] == 9) {
    gg_df[i, ncol(gg_df)] <- "OPC"
  } else if (seurat_hvg_clusters[i] == 10) {
    gg_df[i, ncol(gg_df)] <- "MG"
  } else if (seurat_hvg_clusters[i] == 11) {
    gg_df[i, ncol(gg_df)] <- "END"
  } else if (seurat_hvg_clusters[i] == 12) {
    gg_df[i, ncol(gg_df)] <- "Unlabeled1"
  } else if (seurat_hvg_clusters[i] == 13) {
    gg_df[i, ncol(gg_df)] <- "NSC"
  } else if (seurat_hvg_clusters[i] == 14) {
    gg_df[i, ncol(gg_df)] <- "ASC2"
  } else if (seurat_hvg_clusters[i] == 15) {
    gg_df[i, ncol(gg_df)] <- "Unlabeled2.1"
  } else if (seurat_hvg_clusters[i] == 16) {
    gg_df[i, ncol(gg_df)] <- "exPFC2"
  } else if (seurat_hvg_clusters[i] == 17) {
    gg_df[i, ncol(gg_df)] <- "exCA1"
  } else if (seurat_hvg_clusters[i] == 18) {
    gg_df[i, ncol(gg_df)] <- "Unlabeled2.2"}}

colData(sce_hvg) <- cbind(
  colData(sce_hvg), seurat_hvg_clusters = gg_df$seurat_hvg_clusters,
  seurat_hvg_clusters_name = gg_df$seurat_hvg_clusters_name)
colData(sce) <- cbind(
  colData(sce), seurat_hvg_clusters = gg_df$seurat_hvg_clusters,
  seurat_hvg_clusters_name = gg_df$seurat_hvg_clusters_name)
gg_df$seurat_hvg_clusters_name <- factor(gg_df$seurat_hvg_clusters_name)
```

### Seurat Clusters Habib tSNE

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  seurat_hvg_clusters_name = levels(gg_df$seurat_hvg_clusters_name),
  label = levels(gg_df$seurat_hvg_clusters_name))
label_df2 <- gg_df %>%
  group_by(seurat_hvg_clusters_name) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "habib_tsne1", y = "habib_tsne2",
  col = "seurat_hvg_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("HVG Seurat Clusters Habib tSNE")
```

### Habib Clusters Habib tSNE

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  habib_cluster_name = levels(gg_df$habib_cluster_name), label = levels(gg_df$habib_cluster_name))
label_df2 <- gg_df %>%
  group_by(habib_cluster_name) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "habib_tsne1", y = "habib_tsne2",col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("Habib Clusters Habib tSNE")
```

### Seurat Clusters HVG tSNE

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  seurat_hvg_clusters_name = levels(gg_df$seurat_hvg_clusters_name),
  label = levels(gg_df$seurat_hvg_clusters_name))
label_df2 <- gg_df %>%
  group_by(seurat_hvg_clusters_name) %>%
  summarize(hvg_tsne1 = median(hvg_tsne1), hvg_tsne2 = median(hvg_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne1", y = "hvg_tsne2", col = "seurat_hvg_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("HVG Seurat Clusters HVG tSNE")
```

### Habib Clusters HVG tSNE

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  habib_cluster_name = levels(gg_df$habib_cluster_name), label = levels(gg_df$habib_cluster_name))
label_df2 <- gg_df %>%
  group_by(habib_cluster_name) %>%
  summarize(hvg_tsne1 = median(hvg_tsne1), hvg_tsne2 = median(hvg_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne1", y = "hvg_tsne2", col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("Habib Clusters HVG tSNE")
```

### Original

![](../assets/habib-fig2a.png)

# Differential Expresssion

We examine upregulated genes in cell types formed by combining subclusters to replicate Figure 2d from @habib_massively_2017.

```{r}
seurat_clusters_id <- c(
  "ODC", "exPFC", "ASC", "exDG", "exPFC", "exCA", "GABA", "GABA", "OPC",
  "MG", "END", "NA", "NSC", "ASC", "NA", "exPFC", "exCA", "NA")
names(seurat_clusters_id) <- levels(seurat_hvg)
seurat_hvg <- RenameIdents(seurat_hvg, seurat_clusters_id)
rm(add_df, gg_df, label_df, label_df2)
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "seurat_hvg_markers.rds")
if (file.exists(rds)) {
  seurat_hvg_markers <- readRDS(rds)
} else {
  seurat_hvg_markers <- FindAllMarkers(seurat_hvg, only.pos = TRUE)
  saveRDS(seurat_hvg_markers, rds)}
```

```{r}
top <- seurat_hvg_markers %>% group_by(cluster) %>% top_n(n = 5, wt = avg_logFC)
DoHeatmap(seurat_hvg, features = top$gene, size = 1.5) +
  NoLegend() + scale_fill_gradientn(colors = c("blue", "white", "red"))
```

**Original**

![](../assets/habib-fig2d.png)

## Marker Genes {.tabset}

We probe 6 select marker genes to replicate Figure 2b.

```{r}
seurat <- as.Seurat(sce, counts = "counts", data = NULL) # Missing genes when using sce_hvg.
habib_tsne <- as.matrix(data.frame(sce$habib_tsne1, sce$habib_tsne2))
colnames(habib_tsne) <- paste0("HabibTSNE_", 1:2)
rownames(habib_tsne) <- colnames(sce)
seurat[["habib_tsne"]] <- CreateDimReducObject(
  embeddings = habib_tsne, key = "HabibTSNE_", assay = DefaultAssay(seurat))
genes <- c("SLC17A7", "SLC1A2", "GAD1", "MBP", "PPFIA2", "PDGFRA")
rm(top, habib_tsne)
```

### Habib tSNE

```{r}
FeaturePlot(
  seurat, reduction = "habib_tsne", features = genes, order = TRUE,
  cols = c("lightgrey", "red"), max.cutoff = 20, ncol = 2)
```

### All Genes tSNE

```{r}
FeaturePlot(
  seurat, reduction = "TSNE", features = genes, order = TRUE,
  cols = c("lightgrey", "red"), max.cutoff = 20, ncol = 2)
```

### Original

![](../assets/habib-fig2b.png)

# References

This is the concluding section of the document.
Here we write relevant results to disk, output the `sessionInfo`, and create a bibliography for works cited.

```{r}
saveRDS(sce_orig, file.path(results_dir, "data", "sce_orig.rds"))
saveRDS(sce, file.path(results_dir, "data", "sce.rds"))
saveRDS(sce_hvg, file.path(results_dir, "data", "sce_hvg.rds"))
saveRDS(seurat_hvg, file.path(results_dir, "data", "seurat_hvg.rds"))
saveRDS(seurat_hvg_markers, file.path(results_dir, "data", "seurat_hvg_markers.rds"))

sessionInfo()
```
