---
title:               "Habib 2017 snRNAseq Report"
author:
  - name:            "Emir Turkes"
  - name:            "Columbia University"
date:                '`r strftime(Sys.time(), format = "%B %d, %Y")`'
bibliography:        "../habib-2017-snRNAseq.bib"
biblio-style:        apalike
link-citations:      true
output:
  html_document:
    number_sections: true
    theme:           lumen
    toc:             true
    toc_depth:       2
    toc_float:
      collapsed:     false
      smooth_scroll: false
knit:
  (function(inputFile, encoding) {
    rmarkdown::render(
      inputFile, encoding = encoding, output_file = "../results/habib-2017-snRNAseq-report.html")})
---

```{r, include = FALSE}
#    This file is part of habib-2017-snRNAseq.
#    Copyright (C) 2019  Emir Turkes
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Emir Turkes can be contacted at emir.turkes@eturkes.com

knitr::opts_chunk$set(echo = TRUE)
```

<style type="text/css">
body {font-size: 16px;}
h1.title {font-size: 35px;}
h1 {font-size: 24px;}
h2 {font-size: 22px;}
h3 {font-size: 20px;}
.toc-content {padding-left: 0px; padding-right: 0px;}
div.tocify {width: 100%;}
.tocify-subheader .tocify-item {font-size: 0.95em; padding-left: 25px; text-indent: 0;}
div.main-container {max-width: none; width: 100%;}
</style>

*This is a broad initial analysis that prepares and characterizes the data for use in other projects.*

The background for this data is as follows:

- dbGaP Accession: [phs000424](https://www.ncbi.nlm.nih.gov/projects/gap/cgi-bin/study.cgi?study_id=phs000424.v7.p2).
- Part of [GTEx](https://gtexportal.org/home/) and originally published in @habib_massively_2017.
- Archived frozen adult human post-mortem tissue.
- 19,550 nuclei, 1,683 genes, 2,187 transcripts.
- 3 PFC samples, 4 hippocampus samples from 5 donors.

This analysis was performed in R except where noted.
The source code and instructions for rerunning the analysis can be found at [github.com/eturkes/habib-2017-snRNAseq](https://github.com/eturkes/habib-2017-snRNAseq).

# Final Results

**Read just this section for the final results of the analysis and a summary of the methods.**

# ~~~~ Breakdown of Methods ~~~~ {-}

The following top-level sections breakdown the methods used to perform the analysis.
We start by setting some global variables and loading in any required packages.

```{r}
data_dir <- file.path(getwd(), "..", "data")
results_dir <- file.path(getwd(), "..", "results")
```

```{r}
library(conflicted)
library(devtools)
library(data.table)
library(DT)
library(plyr)
library(SingleCellExperiment)
library(biomaRt)
library(dplyr)
library(SummarizedExperiment)
library(DropletUtils)
library(scater)
library(scran)
```

# Original Data {.tabset}

This section provides a brief look at the raw data before manipulation.

## Counts

```{r, cache = TRUE}
# This chunk was run with "cache = TRUE".
counts <- fread(file.path(data_dir, "GTEx_droncseq_hip_pcf.umi_counts.txt.gz"), data.table = FALSE)
```

```{r}
datatable(counts[1:5, 1:3])
```

## Clusters

```{r}
clust <- fread(file.path(data_dir, "GTEx_droncseq_hip_pcf.clusters.txt.gz"), data.table = FALSE)
datatable(clust[1:5, ])
```

## t-SNE

```{r}
tsne = fread(file.path(data_dir, "../data/GTEx_droncseq_hip_pcf.tsne.txt.gz"), data.table = FALSE)
datatable(tsne[1:5, ])
```

# Preliminary Cleaning

Here we provide more informative labels to things, subset to the regions/cell types we are interested in, and transform the data into more convenient formats for downstream analysis.

## Relabeling and Subsetting {.tabset}

A more elegant solution is planned, but for now, the desired regions/cell types can be set here.

```{r}
# TODO: Simplify formatting requirements for the variables.
regions <- "*PFC*"
cell_types <- "exPFC1|exPFC2|GABA1|GABA2"
```

### Counts

```{r}
rownames(counts) <- counts$V1
counts <- as.matrix(counts[ , -1])

# For subsetting regions.
keep <- grep(regions, colnames(counts))
counts <- counts[ , keep]

datatable(counts[1:5, 1:3])
```

### Clusters

```{r}
names(clust) <- c("Sample", "Habib Cluster")

# For subsetting regions.
clust <- clust[keep, ]

clust$`Habib Cluster` <- as.factor(clust$`Habib Cluster`)

# Add cluster names from Supplementary Table 8 (nmeth.4407-S11.xlsx).
# The last four clusters lack labels.
cname = c(
  "exPFC1", "exPFC2", "exCA1", "exCA3", "GABA1", "GABA2", "exDG", "ASC1",
  "ASC2", "ODC1", "ODC2", "OPC", "MG", "NSC", "END", rep(NA,4))
ctype = c(
  "exPFC", "exPFC", "exCA1", "exCA3", "GABA", "GABA", "exDG", "ASC",
  "ASC", "ODC", "ODC", "OPC", "MG", "NSC", "END", rep(NA,4))

# Merge cluster names with clust.
map_clust_name <- data.frame(
  "Habib Cluster" = as.factor(seq(19)),
  "Habib Cluster Name" = cname,
  "Habib Cell Type" = ctype,
  stringsAsFactors = FALSE,
  check.names = FALSE)

# Must resolve masking conflict with intersect.
clust <- join(
  clust, map_clust_name, by = BiocGenerics::intersect(names(clust), names(map_clust_name)))

# For subsetting cell type.
ckeep <- grep(cell_types, clust$`Habib Cluster Name`)
clust <- clust[ckeep, ]
counts <- counts[ , ckeep]

# Moved from chunk 1.
part_cell_id <- sapply(colnames(counts), function(xx) strsplit(xx, "_")[[1]][1], USE.NAMES = FALSE)
col_dat <- data.frame(
  "Sample" = colnames(counts),
  "Cell ID Stem" = part_cell_id,
  stringsAsFactors = FALSE,
  check.names = FALSE)

clust <- clust[match(col_dat$Sample, clust$Sample), ]
datatable(clust[1:5, ])
```

### t-SNE

```{r}
names(tsne) = c("Sample", paste0("Habib tSNE ", 1:2))

# For subsetting regions.
tsne <- tsne[keep, ]

# For subsetting cell type.
tsne <- tsne[ckeep, ]

col_dat <- cbind(
  col_dat, clust[ , names(clust) != "Sample"], tsne[ , names(tsne) != "Sample"])
datatable(tsne[1:5, ])
```

## SingleCellExperiment

The data is now sufficiently prepared to form a SingleCellExperiment (SCE) object.

```{r}
sce <- SingleCellExperiment(assays = list(counts = counts), colData = col_dat)
sce
```

## Gene Annotations

To provide additional metadata, we generate annotations based on the hg19 reference gnome, the same used in @habib_massively_2017.

```{r, cache = TRUE}
# This chunk was run with "cache = TRUE".
# Due to issues with cache invalidation, we read in the saved RDS everytime for now.
gene_anno <- readRDS(file.path(results_dir, "data", "gene_anno.rds"))
# ensembl <- useEnsembl(biomart = "ensembl", GRCh = 37, dataset = "hsapiens_gene_ensembl")
# attr_string <- c(
#   "hgnc_symbol", "ensembl_gene_id", "external_gene_name", "chromosome_name", "start_position",
#   "end_position", "strand", "description", "percentage_gene_gc_content", "gene_biotype")
# gene_anno <- getBM(
#   attributes = attr_string, filters = "external_gene_name", values = rownames(sce), mart = ensembl)
# saveRDS(gene_anno, file = file.path(results_dir, "data", "gene_anno.rds"))
```

Before merging it into the SCE object, the annotation must be cleaned by removing genes not in the RNAseq dataset, irrelevant annotations, duplicate genes, and genes that are not annotated.

```{r}
# Remove genes not in the RNAseq dataset.
remove_genes <- which(!gene_anno$external_gene_name %in% rownames(sce))
gene_anno <- gene_anno[-remove_genes, ]

# Remove annotations to scaffolds, assembly patches, and alternative loci.
chromosomes <- c(1:22, "X", "Y", "MT")
gene_anno <- gene_anno[which(gene_anno$chromosome_name %in% chromosomes), ]

# Remove duplicates.
dup <- table(gene_anno$external_gene_name)
dup <- sort(dup[dup > 1], decreasing = TRUE)
dup <- which(gene_anno$external_gene_name %in% names(dup))
gene_anno2 <- gene_anno[dup, ]
gene_anno2 <- gene_anno2[which(gene_anno2$hgnc_symbol == gene_anno2$external_gene_name), ]
gene_anno2 <- distinct(gene_anno2, external_gene_name, .keep_all = TRUE)
gene_anno <- rbind(gene_anno[-dup, ], gene_anno2)

# Remove missing.
keep_genes <- match(gene_anno$external_gene_name, rownames(sce))
sce <- sce[keep_genes, ]
```

```{r}
rowData(sce) <- gene_anno
sce
```

# QC

These sections assess and correct issues and irregularities in the dataset.

## Low Quality Cells

In order to remove droplets which do not contain a cell but are rather ambient RNA, we visualize the inflection point on a knee plot, as described originally in @macosko_highly_2015.
Removal was then to be originally done using `emptyDrops` from the `DropletUtils` package, but due to an unresolved error (`no counts available to estimate the ambient profile`), we skip it.
In any case, all 14,963 cells were used for the analysis in @habib_massively_2017.

```{r}
bc_rank <- barcodeRanks(counts(sce))
uniq <- !duplicated(bc_rank$rank)
par(mar = c(5, 4, 2, 1), bty = "n")
plot(
  bc_rank$rank[uniq], bc_rank$total[uniq], log = "xy", xlab = "Rank",
  ylab = "Total UMI count", cex = 0.5, cex.lab = 1.2)
abline(h = bc_rank$inflection, col = "darkgreen", lty = 2, lwd = 2)
abline(h = bc_rank$knee, col = "dodgerblue", lty = 2, lwd = 2)
legend(
  "left", legend = c("Inflection", "Knee"), bty = "n", col = c("darkgreen", "dodgerblue"),
  lty = 2, cex = 1.2, lwd = 2)
```

## Mito/Ribo Genes

Using an annotation from [HGNC](https://www.genenames.org/), we first identify and then remove mitochondrial/ribosomal genes.

```{r}
ribo_genes <- read.table(
  file.path(results_dir, "data", "ribo-genes.txt"), sep = "\t",
  header = TRUE, stringsAsFactors = FALSE)
is_mito <- which(rowData(sce)$chromosome_name == "MT")
is_ribo <- which(rowData(sce)$external_gene_name %in% ribo_genes$Approved.Symbol)
sce <- calculateQCMetrics(sce, feature_controls = list(Mt = is_mito, Ri = is_ribo))
par(mfrow = c(2, 2), mar = c(5, 4, 1, 1), bty = "n")
hist(
  log10(sce$total_counts), xlab = "log10(Library sizes)", main = "",
  breaks = 20, col = "grey80", ylab = "Number of cells")
hist(
  log10(sce$total_features_by_counts), xlab = "log10(# of expressed genes)", main = "",
  breaks = 20, col = "grey80", ylab = "Number of cells")
hist(
  sce$pct_counts_Ri, xlab = "Ribosome prop. (%)", ylab = "Number of cells",
  breaks = 40, main = "", col = "grey80")
hist(
  sce$pct_counts_Mt, xlab = "Mitochondrial prop. (%)", ylab = "Number of cells",
  breaks = 80, main = "", col = "grey80")
par(mfrow = c(2, 2), mar = c(5, 4, 1, 1), bty = "n")
smoothScatter(
  log10(sce$total_counts), log10(sce$total_features_by_counts),
  xlab = "log10(Library sizes)", ylab = "log10(# of expressed genes)")
smoothScatter(
  log10(sce$total_counts), sce$pct_counts_Ri,
  xlab = "log10(Library sizes)", ylab = "Ribosome prop. (%)")
smoothScatter(
  log10(sce$total_counts), sce$pct_counts_Mt,
  xlab = "log10(Library sizes)", ylab = "Mitochondrial prop. (%)")
smoothScatter(
  sce$pct_counts_Ri,sce$pct_counts_Mt, xlab = "Ribosome prop. (%)", ylab = "Mitochondrial prop. (%)")
```

```{r}
libsize_drop <- isOutlier(sce$total_counts, nmads = 3, type = "lower", log = TRUE)
feature_drop <- isOutlier(sce$total_features_by_counts, nmads = 3, type = "lower", log = TRUE)
mito_drop <- isOutlier(sce$pct_counts_Mt, nmads = 3, type = "higher")
ribo_drop <- isOutlier(sce$pct_counts_Ri, nmads = 3, type = "higher")
keep <- !(libsize_drop | feature_drop | mito_drop | ribo_drop)
sce <- sce[ , keep]
```

## Lowly Expressed Genes

As described in @habib_massively_2017,

> Nuclei with less than 200 detected genes and less than 10,000 usable reads were filtered out.

and

> A gene is considered detected in a cell if it has at least two unique UMIs (transcripts) associated with it.
For each analysis, genes were removed that were detected in less than 10 nuclei.

From these descriptions we conclude that nuclei that have less than 200 genes in one or more UMIs should be removed. We start by first visualizing some gene-level summary statistics, followed by removal of the neccessary genes, and then a visualization of the most highly expressed genes.

```{r}
par(mfrow = c(1, 3), mar = c(5, 4, 1, 1))
hist(
  log10(rowData(sce)$mean_counts + 1e-6), col = "grey80",  main = "",
  breaks = 40, xlab = "log10(ave # of UMI + 1e-6)")
hist(
  log10(rowData(sce)$n_cells_by_counts + 1), col = "grey80", main = "",
  breaks = 40, xlab = "log10(# of expressed cells + 1)")
plot(
  log10(rowData(sce)$mean_counts + 1e-6), pch = 16,
  col = rgb(0, 0, 0, 0.4), log10(rowData(sce)$n_cells_by_counts + 1),
  xlab = "log10(ave # of UMI + 1e-6)", ylab = "log10(# of expressed cells + 1)")
```

```{r}
names(rowData(sce))[names(rowData(sce)) == "strand"] <- "strand_n" # Must be renamed due to error.
n_genes <- colSums(counts(sce) >= 2)
n_genes <- colSums(counts(sce) >= 1)
n_cells <- rowSums(counts(sce) >= 2)
sce <- sce[which(n_cells >= 10), ]
```

```{r}
par(mar = c(5, 4, 1, 1))
od1 <- order(rowData(sce)$mean_counts, decreasing = TRUE)
barplot(
  rowData(sce)$mean_counts[od1[20:1]], las = 1, names.arg = rowData(sce)$hgnc_symbol[od1[20:1]],
  horiz = TRUE, cex.names = 0.8, cex.axis = 0.8,
  xlab = "ave # of UMI")
```

## Normalization

We use `computeSumFactors` from the `scran` package to perform normalization.
This function uses a linear deconvolution system to account for expected variation across different cell types/sizes [@l_lun_pooling_2016].
We also remove cells that have size factors from the function that are very small ($ < 0.01$) or negative.
To verify the effectiveness of this method, we plot each cell's size factor against their total counts, which has the result of being highly correlated.

```{r}
clusters <- quickCluster(sce, min.mean = 0.1, method = "igraph")
sce <- computeSumFactors(sce, cluster = clusters, min.mean = 0.1)
sce <- sce[ , which(sizeFactors(sce) > 0.01)]
par(mfrow = c(1, 2), mar = c(5, 4, 2, 1), bty = "n")
smoothScatter(
  sce$total_counts, sizeFactors(sce), log = "xy", xlab = "total counts", ylab = "size factors")
plot(
  sce$total_counts, sizeFactors(sce), log = "xy", xlab = "total counts",
  ylab = "size factors", cex = 0.3, pch = 20, col = rgb(0.1, 0.2, 0.7, 0.3))
abline(h = 0.05)
```

```{r}
sce <- sce[ , which(sizeFactors(sce) > 0.05)]
sce <- normalize(sce)
```

# References

This is the concluding section of the document.
Here we write relevant results to disk, output the `session_info`, and create a bibliography for works cited.

```{r}
session_info()
```
